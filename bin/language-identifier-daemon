#!/usr/bin/env ruby
#
# Idea taken from: https://gist.github.com/ik5/448884
#
require 'rubygems'
require 'spoon'
require_relative '../lib/opener/language_identifier/opt_parser'

PID_PATH = (ENV["PID_PATH"] ||= "/var/run/language-identifier.pid")

def create_pid(pid)
  begin
    open(PID_PATH, 'w') do |f|
      f.puts pid
    end
  rescue => e
    STDERR.puts "Error: Unable to open #{PID_PATH} for writing:\n\t" +
      "(#{e.class}) #{e.message}"
    exit!
  end
end

def get_pid
  pid = false
  begin
    open(PID_PATH, 'r') do |f|
      pid = f.readline
      pid = pid.to_s.gsub(/[^0-9]/,'')
    end
  rescue => e
    STDERR.puts "Error: Unable to open #{PID_PATH} for reading:\n\t" +
      "(#{e.class}) #{e.message}"
  end

  pid.to_i
end

def remove_pidfile
  begin
    File.unlink(PID_PATH)
  rescue => e
    STDERR.puts "ERROR: Unable to unlink #{path}:\n\t" +
      "(#{e.class}) #{e.message}"
    exit
  end
end

def process_exists?
  begin
    pid = get_pid
    return false unless pid
    Process.kill(0, pid)
    true
  rescue Errno::ESRCH, TypeError # "PID is NOT running or is zombied
    false
  rescue Errno::EPERM
    STDERR.puts "No permission to query #{pid}!";
  rescue => e
    STDERR.puts "(#{e.class}) #{e.message}:\n\t" +
      "Unable to determine status for #{pid}."
      false
  end
end

def stop
  begin
    pid = get_pid
    STDERR.puts "pid : #{pid}"
    while true do
      Process.kill("TERM", pid)
      Process.wait(pid)
      sleep(0.1)
    end
    puts "here"
  rescue Errno::ESRCH # no more process to kill
    remove_pidfile
    STDOUT.puts 'Stopped the process'
  rescue => e
    STDERR.puts "unable to terminate process: (#{e.class}) #{e.message}"
  end
end

def start
  if process_exists?
    STDERR.puts "The process #{exec} already running. Restarting the process"
    stop
  end

  pid = Spoon.spawnp exec, *ARGV
  create_pid(pid)
  Process.setsid
  #at_exit do
  #  remove_pidfile
  #end

  Dir::chdir(WORK_PATH)
  File::umask(0)
  #STDIN.reopen("/dev/null", 'r')
  #STDOUT.reopen("/dev/null", "w")
  #STDERR.reopen("/dev/null", "w")
end

def exec
  file = File.expand_path("../../exec/language-identifier.rb", __FILE__)
  "ruby #{file} #{ARGV.join(" ")}"
end


if ARGV[0] == 'start'
  start
elsif ARGV[0] == 'stop'
  stop
elsif ARGV[0] == 'restart'
  stop
  start
elsif ARGV[0] == '-h'
  Opener::LanguageIdentifier::OptParser.parse!(ARGV)
else
  puts "Usage: language-identifier <start|stop|restart> [options]"
  puts "Or for help use: language-identifier -h"
  exit!
end
